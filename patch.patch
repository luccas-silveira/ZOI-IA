diff --git a/tag_tracker.py b/tag_tracker.py
index 75f93a9aefa8f5e128bc9a7b3d772ede9688bfa0..15890c4a0174e313ccaeb59ea420a69839c0bce9 100644
--- a/tag_tracker.py
+++ b/tag_tracker.py
@@ -1,69 +1,76 @@
 import asyncio
 import base64
 import json
 import logging
+import os
 from datetime import datetime, timezone
 from pathlib import Path
 
 from aiohttp import web
 import httpx
 
 from summarizer import summarize
 
+try:  # pragma: no cover - openai é opcional
+    from openai import AsyncOpenAI
+except Exception:  # pragma: no cover
+    AsyncOpenAI = None
+
 # =========================
 # Configurações
 # =========================
 TAG_NAME = "ia - ativa"
 STORE_PATH = Path("tag_ia_atendimento_ativa.json")
 MESSAGES_DIR = Path("messages")
 LOCATION_TOKEN_PATH = Path("location_token.json")
 PORT = 8081
 
 # Opcional: verificar assinatura RSA dos webhooks (requer 'cryptography')
 VERIFY_SIGNATURE = True
 
 # Chave pública oficial (Webhook Authentication Guide)
 PUBLIC_KEY_PEM = b"""-----BEGIN PUBLIC KEY-----
 MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAokvo/r9tVgcfZ5DysOSC
 Frm602qYV0MaAiNnX9O8KxMbiyRKWeL9JpCpVpt4XHIcBOK4u3cLSqJGOLaPuXw6
 dO0t6Q/ZVdAV5Phz+ZtzPL16iCGeK9po6D6JHBpbi989mmzMryUnQJezlYJ3DVfB
 csedpinheNnyYeFXolrJvcsjDtfAeRx5ByHQmTnSdFUzuAnC9/GepgLT9SM4nCpv
 uxmZMxrJt5Rw+VUaQ9B8JSvbMPpez4peKaJPZHBbU3OdeCVx5klVXXZQGNHOs8gF
 3kvoV5rTnXV0IknLBXlcKKAQLZcY/Q9rG6Ifi9c+5vqlvHPCUJFT5XUGG5RKgOKU
 J062fRtN+rLYZUV+BjafxQauvC8wSWeYja63VSUruvmNj8xkx2zE/Juc+yjLjTXp
 IocmaiFeAO6fUtNjDeFVkhf5LNb59vECyrHD2SQIrhgXpO4Q3dVNA5rw576PwTzN
 h/AMfHKIjE4xQA1SZuYJmNnmVZLIZBlQAF9Ntd03rfadZ+yDiOXCCs9FkHibELhC
 HULgCsnuDJHcrGNd5/Ddm5hxGQ0ASitgHeMZ0kcIOwKDOzOU53lDza6/Y09T7sYJ
 PQe7z0cvj7aE4B+Ax1ZoZGPzpJlZtGXCsu9aTEGEnKzmsFqwcSsnw3JB31IGKAyk
 T1hhTiaCeIY/OwwwNUY2yvcCAwEAAQ==
 -----END PUBLIC KEY-----"""
 
 # Memória (simples) para idempotência
 PROCESSED_TAGS = set()
 PROCESSED_MESSAGES = set()
 PROCESSED_OUTBOUND_MESSAGES = set()
+AI_GENERATED_MESSAGES = set()
 
 def now_iso():
     return datetime.now(timezone.utc).isoformat()
 
 def load_store():
     if STORE_PATH.exists():
         try:
             return json.loads(STORE_PATH.read_text(encoding="utf-8"))
         except Exception:
             logging.exception("Falha lendo o store; recriando.")
     # Apenas IDs
     return {"lastUpdate": now_iso(), "contactIds": []}
 
 def save_store(store):
     store["lastUpdate"] = now_iso()
     STORE_PATH.write_text(json.dumps(store, ensure_ascii=False, indent=2), encoding="utf-8")
 
 def load_contact_messages(contact_id: str):
     MESSAGES_DIR.mkdir(exist_ok=True)
     path = MESSAGES_DIR / f"{contact_id}.json"
     if path.exists():
         try:
             data = json.loads(path.read_text(encoding="utf-8"))
             data.setdefault("messages", [])
             data.setdefault("context", "")
diff --git a/tag_tracker.py b/tag_tracker.py
index 75f93a9aefa8f5e128bc9a7b3d772ede9688bfa0..15890c4a0174e313ccaeb59ea420a69839c0bce9 100644
--- a/tag_tracker.py
+++ b/tag_tracker.py
@@ -90,95 +97,168 @@ async def update_context(store: dict, flush_all: bool = False) -> None:
         return
 
     if flush_all:
         # Processa todas as mensagens, mantendo as mais recentes no início
         to_summarize = messages
         remaining = []
     else:
         # Resume as mensagens mais antigas, localizadas ao final da lista
         to_summarize = messages[-15:]
         remaining = messages[:-15]
 
     combined = list(to_summarize)
     if context:
         combined.append({"direction": "context", "body": context})
     store["context"] = await summarize(combined)
     store["messages"] = remaining
 
 def load_location_token():
     try:
         data = json.loads(LOCATION_TOKEN_PATH.read_text(encoding="utf-8"))
         return data.get("access_token")
     except Exception:
         logging.exception("Falha lendo location_token.json")
         return None
 
+def load_location_credentials():
+    """Retorna o access token e o location id."""
+    try:
+        data = json.loads(LOCATION_TOKEN_PATH.read_text(encoding="utf-8"))
+        return data.get("access_token"), data.get("location_id")
+    except Exception:
+        logging.exception("Falha lendo location_token.json")
+        return None, None
+
 async def fetch_conversation_messages(conversation_id: str, limit: int = 30):
     token = load_location_token()
     if not token:
         return []
     url = (
         f"https://services.leadconnectorhq.com/conversations/{conversation_id}/messages"
         f"?limit={limit}"
     )
     headers = {
         "Authorization": f"Bearer {token}",
         "Accept": "application/json",
         "Version": "2021-04-15",
     }
     try:
         async with httpx.AsyncClient() as client:
             resp = await client.get(url, headers=headers, timeout=10)
             resp.raise_for_status()
             payload = resp.json()
     except Exception:
         logging.exception("Falha buscando mensagens da conversa %s", conversation_id)
         return []
 
     raw_messages = payload.get("messages", [])
     if isinstance(raw_messages, dict):
         raw_messages = raw_messages.get("messages", [])
     if not isinstance(raw_messages, list):
         logging.warning("Formato inesperado de mensagens: %r", raw_messages)
         return []
 
     # A API retorna da mensagem mais antiga para a mais recente;
     # invertemos para manter a mais nova no início da lista.
     messages = []
     for item in reversed(raw_messages):
         if not isinstance(item, dict):
             logging.warning("Mensagem inesperada no payload: %r", item)
             continue
         body = item.get("body") or item.get("text") or ""
         direction = item.get("direction") or item.get("messageDirection")
         direction = "outbound" if direction == "outbound" else "inbound"
         messages.append({
             "direction": direction,
             "body": body,
         })
     return messages
 
+
+async def generate_reply(store: dict) -> str:
+    """Gera uma resposta utilizando o contexto e a última mensagem recebida."""
+    context = store.get("context") or ""
+    last_inbound = ""
+    for msg in store.get("messages", []):
+        if msg.get("direction") == "inbound":
+            last_inbound = msg.get("body", "")
+            break
+    if not last_inbound:
+        return ""
+    if AsyncOpenAI is None:
+        return ""
+    prompt = f"Contexto:\n{context}\n\nMensagem:\n{last_inbound}"
+    try:
+        client = AsyncOpenAI()
+        resp = await client.chat.completions.create(
+            model=os.getenv("OPENAI_MODEL", "gpt-3.5-turbo"),
+            messages=[
+                {
+                    "role": "system",
+                    "content": "Você é um assistente que responde de forma educada.",
+                },
+                {"role": "user", "content": prompt},
+            ],
+        )
+        return resp.choices[0].message.content.strip()
+    except Exception as exc:  # pragma: no cover
+        logging.exception("Falha gerando resposta: %s", exc)
+        return ""
+
+
+async def send_outbound_message(contact_id: str, conversation_id: str, body: str) -> bool:
+    """Envia uma mensagem para o contato informado."""
+    token, location_id = load_location_credentials()
+    if not token or not contact_id or not location_id:
+        return False
+    url = "https://services.leadconnectorhq.com/conversations/messages"
+    headers = {
+        "Authorization": f"Bearer {token}",
+        "Content-Type": "application/json",
+        "Accept": "application/json",
+        "Version": "2021-07-28",
+    }
+    payload = {
+        "locationId": location_id,
+        "contactId": contact_id,
+        "message": body,
+        "type": "SMS",
+    }
+    if conversation_id:
+        payload["conversationId"] = conversation_id
+    try:
+        async with httpx.AsyncClient() as client:
+            resp = await client.post(url, headers=headers, json=payload, timeout=10)
+            resp.raise_for_status()
+            AI_GENERATED_MESSAGES.add((conversation_id, body))
+            return True
+    except httpx.HTTPStatusError as exc:  # pragma: no cover
+        logging.error("Erro HTTP %s: %s", exc.response.status_code, exc.response.text)
+    except Exception:  # pragma: no cover
+        logging.exception("Falha enviando mensagem para %s", contact_id)
+    return False
+
 def verify_signature(payload_bytes: bytes, signature_b64: str) -> bool:
     if not VERIFY_SIGNATURE:
         return True
     try:
         from cryptography.hazmat.primitives.serialization import load_pem_public_key
         from cryptography.hazmat.primitives.asymmetric import padding
         from cryptography.hazmat.primitives import hashes
     except Exception:
         logging.warning("biblioteca 'cryptography' não instalada; pulando verificação de assinatura")
         return True  # aceite, mas logue
 
     try:
         pub = load_pem_public_key(PUBLIC_KEY_PEM)
         sig = base64.b64decode(signature_b64)
         pub.verify(sig, payload_bytes, padding.PKCS1v15(), hashes.SHA256())
         return True
     except Exception as e:
         logging.error("Assinatura inválida: %s", e)
         return False
 
 async def handle_health(_req):
     return web.json_response({"ok": True})
 
 async def handle_list(_req):
     store = load_store()
diff --git a/tag_tracker.py b/tag_tracker.py
index 75f93a9aefa8f5e128bc9a7b3d772ede9688bfa0..15890c4a0174e313ccaeb59ea420a69839c0bce9 100644
--- a/tag_tracker.py
+++ b/tag_tracker.py
@@ -277,76 +357,97 @@ async def handle_inbound_message(request: web.Request):
 
     contact_id = event.get("contactId")
     if not contact_id:
         return web.json_response({"error": "missing contact id"}, status=422)
     body = event.get("body")
     conversation_id = event.get("conversationId")
 
     store = load_contact_messages(contact_id)
     if conversation_id is not None:
         store["conversationId"] = conversation_id
         if not store.get("historyFetched"):
             history = await fetch_conversation_messages(conversation_id)
             store["messages"] = history
             store["historyFetched"] = True
     msgs = store.get("messages") or []
     msgs.insert(0, {
         "direction": "inbound",
         "body": body,
         "conversationId": conversation_id,
     })
     store["messages"] = msgs
     if len(store["messages"]) >= 30:
         await update_context(store)
     save_contact_messages(contact_id, store)
 
+    store_tags = load_store()
+    if contact_id in set(store_tags.get("contactIds") or []):
+        reply = await generate_reply(store)
+        if reply:
+            ok = await send_outbound_message(contact_id, conversation_id, reply)
+            if ok:
+                msgs = store.get("messages") or []
+                msgs.insert(0, {
+                    "direction": "outbound",
+                    "body": reply,
+                    "conversationId": conversation_id,
+                })
+                store["messages"] = msgs
+                if len(store["messages"]) >= 30:
+                    await update_context(store)
+                save_contact_messages(contact_id, store)
+
     return web.json_response({"ok": True})
 
 async def handle_outbound_message(request: web.Request):
     raw = await request.read()
 
     sig = request.headers.get("x-wh-signature") or request.headers.get("X-Wh-Signature")
     if sig and not verify_signature(raw, sig):
         return web.json_response({"error": "invalid signature"}, status=401)
 
     try:
         event = json.loads(raw.decode("utf-8"))
     except Exception:
         return web.json_response({"error": "invalid json"}, status=400)
 
     wh_id = event.get("webhookId")
     if wh_id:
         if wh_id in PROCESSED_OUTBOUND_MESSAGES:
             return web.json_response({"ok": True, "dedup": True})
         PROCESSED_OUTBOUND_MESSAGES.add(wh_id)
 
     contact_id = event.get("contactId")
     if not contact_id:
         return web.json_response({"error": "missing contact id"}, status=422)
     body = event.get("body")
     conversation_id = event.get("conversationId")
 
+    if (conversation_id, body) in AI_GENERATED_MESSAGES:
+        AI_GENERATED_MESSAGES.discard((conversation_id, body))
+        return web.json_response({"ok": True, "ignored": True})
+
     store = load_contact_messages(contact_id)
     if conversation_id is not None:
         store["conversationId"] = conversation_id
         if not store.get("historyFetched"):
             history = await fetch_conversation_messages(conversation_id)
             store["messages"] = history
             store["historyFetched"] = True
     msgs = store.get("messages") or []
     msgs.insert(0, {
         "direction": "outbound",
         "body": body,
         "conversationId": conversation_id,
     })
     store["messages"] = msgs
     if len(store["messages"]) >= 30:
         await update_context(store)
     save_contact_messages(contact_id, store)
 
     return web.json_response({"ok": True})
 
 def build_app():
     app = web.Application()
     app.add_routes(
         [
             web.get("/healthz", handle_health),
