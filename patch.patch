diff --git a/tag_tracker.py b/tag_tracker.py
index 5804bc3bea9f8c14fb55637f7254789ea3ab6dad..a289d51e850cde17d0a67ff4daf517e920c0f169 100644
--- a/tag_tracker.py
+++ b/tag_tracker.py
@@ -98,52 +98,62 @@ def load_location_token():
         logging.exception("Falha lendo location_token.json")
         return None
 
 async def fetch_conversation_messages(conversation_id: str, limit: int = 30):
     token = load_location_token()
     if not token:
         return []
     url = (
         f"https://services.leadconnectorhq.com/conversations/{conversation_id}/messages"
         f"?limit={limit}"
     )
     headers = {
         "Authorization": f"Bearer {token}",
         "Accept": "application/json",
         "Version": "2021-04-15",
     }
     try:
         async with httpx.AsyncClient() as client:
             resp = await client.get(url, headers=headers, timeout=10)
             resp.raise_for_status()
             payload = resp.json()
     except Exception:
         logging.exception("Falha buscando mensagens da conversa %s", conversation_id)
         return []
 
+    raw_messages = payload.get("messages", [])
+    if isinstance(raw_messages, dict):
+        raw_messages = raw_messages.get("messages", [])
+    if not isinstance(raw_messages, list):
+        logging.warning("Formato inesperado de mensagens: %r", raw_messages)
+        return []
+
     messages = []
-    for item in payload.get("messages", []):
+    for item in raw_messages:
+        if not isinstance(item, dict):
+            logging.warning("Mensagem inesperada no payload: %r", item)
+            continue
         body = item.get("body") or item.get("text") or ""
         direction = item.get("direction") or item.get("messageDirection")
         direction = "outbound" if direction == "outbound" else "inbound"
         messages.append({
             "direction": direction,
             "body": body,
             "conversationId": conversation_id,
         })
     return messages
 
 def verify_signature(payload_bytes: bytes, signature_b64: str) -> bool:
     if not VERIFY_SIGNATURE:
         return True
     try:
         from cryptography.hazmat.primitives.serialization import load_pem_public_key
         from cryptography.hazmat.primitives.asymmetric import padding
         from cryptography.hazmat.primitives import hashes
     except Exception:
         logging.warning("biblioteca 'cryptography' não instalada; pulando verificação de assinatura")
         return True  # aceite, mas logue
 
     try:
         pub = load_pem_public_key(PUBLIC_KEY_PEM)
         sig = base64.b64decode(signature_b64)
         pub.verify(sig, payload_bytes, padding.PKCS1v15(), hashes.SHA256())
