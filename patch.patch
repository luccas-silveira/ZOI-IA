diff --git a/tag_tracker.py b/tag_tracker.py
index 32a5acd420051707087ca1869653afb0c3572f29..8e44e0dbf3e057e71ba4a3b268d8bda217663e3b 100644
--- a/tag_tracker.py
+++ b/tag_tracker.py
@@ -99,50 +99,100 @@ def load_location_token():
         return None
 
 async def fetch_existing_messages(contact_id: str):
     token = load_location_token()
     if not token:
         return []
     url = f"https://services.leadconnectorhq.com/conversations/{contact_id}"
     headers = {"Authorization": f"Bearer {token}"}
     try:
         async with httpx.AsyncClient() as client:
             resp = await client.get(url, headers=headers, timeout=10)
             resp.raise_for_status()
             payload = resp.json()
     except Exception:
         logging.exception("Falha buscando histórico de %s", contact_id)
         return []
 
     messages = []
     for item in payload.get("messages", []):
         body = item.get("body") or item.get("text") or ""
         direction = item.get("direction") or item.get("messageDirection")
         direction = "outbound" if direction == "outbound" else "inbound"
         messages.append({"direction": direction, "body": body})
     return messages
 
+
+async def fetch_conversation_messages(conversation_id: str):
+    token = load_location_token()
+    if not token:
+        return []
+    url = f"https://services.leadconnectorhq.com/conversations/{conversation_id}"
+    headers = {"Authorization": f"Bearer {token}"}
+    try:
+        async with httpx.AsyncClient() as client:
+            resp = await client.get(url, headers=headers, timeout=10)
+            resp.raise_for_status()
+            payload = resp.json()
+    except Exception:
+        logging.exception("Falha buscando mensagens da conversa %s", conversation_id)
+        return []
+
+    raw_messages = payload.get("messages")
+    messages_source = []
+    if isinstance(raw_messages, list):
+        messages_source = raw_messages
+    elif isinstance(raw_messages, dict):
+        messages_source = raw_messages.get("messages") or raw_messages.get("items") or []
+        if not isinstance(messages_source, list):
+            logging.warning(
+                "Formato inesperado de mensagens dentro do dict para conversa %s: %r",
+                conversation_id,
+                raw_messages,
+            )
+            messages_source = []
+    elif raw_messages is not None:
+        logging.warning(
+            "Formato inesperado para payload['messages'] da conversa %s: %r",
+            conversation_id,
+            raw_messages,
+        )
+        return []
+    else:
+        return []
+
+    messages = []
+    for item in messages_source:
+        if not isinstance(item, dict):
+            logging.warning("Item de mensagem inesperado: %r", item)
+            continue
+        body = item.get("body") or item.get("text") or ""
+        direction = item.get("direction") or item.get("messageDirection")
+        direction = "outbound" if direction == "outbound" else "inbound"
+        messages.append({"direction": direction, "body": body})
+    return messages
+
 def verify_signature(payload_bytes: bytes, signature_b64: str) -> bool:
     if not VERIFY_SIGNATURE:
         return True
     try:
         from cryptography.hazmat.primitives.serialization import load_pem_public_key
         from cryptography.hazmat.primitives.asymmetric import padding
         from cryptography.hazmat.primitives import hashes
     except Exception:
         logging.warning("biblioteca 'cryptography' não instalada; pulando verificação de assinatura")
         return True  # aceite, mas logue
 
     try:
         pub = load_pem_public_key(PUBLIC_KEY_PEM)
         sig = base64.b64decode(signature_b64)
         pub.verify(sig, payload_bytes, padding.PKCS1v15(), hashes.SHA256())
         return True
     except Exception as e:
         logging.error("Assinatura inválida: %s", e)
         return False
 
 async def handle_health(_req):
     return web.json_response({"ok": True})
 
 async def handle_list(_req):
     store = load_store()
